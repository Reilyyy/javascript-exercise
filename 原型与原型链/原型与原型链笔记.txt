原型和原型链



这个问题的产生是为了实现原型上属性和方法的继承，提高代码的复用率。构造函数就相当于模具，但是关于这个模具具体的一些属性，比如大小，材质之类的并没有直接写在模具里，而是把这些属性和方法放在了原型（prototype）里，在构造函数内部通过__proto__属性将两者绑定了。在js万物皆对象的思想下，__proto__属性是每个对象都有的，包括原型。
ps：因为绝大部分浏览器都支持__proto__属性，所以它才被加入了 ES6 里（ES5 部分浏览器也支持，但还不是标准）。

然后在有了模具的前提下，就可以来创造实例了，但是实例不光可以继承属性和方法，还可以有自己的属性和方法。就像父子的关系一样，虽然相似但也有不同。而原型中也有一个属性指向创造出来的实例，就是构造器（constructor）属性，构造器（constructor，包括: Object；Function；Array；Date；String等函数）才有prototype属性，对象（除Object外）都拥有__proto__。

所以在通过构造函数创造实例的过程中，构造函数只是一个桥梁，将实例通过原型创造出来了而已，在实例被创造出来的时候，构造函数中的this指针就已经指向被创造的实例，实例的__proto__就指向了实例的原型，而构造函数就退出历史舞台。而原型链指的是，在找寻某个实例的方法和属性的过程中，先在自身查找，然后通过实例的__proto__找到实例的原型，实例的原型再通过实例的原型的__proto__找到了Object的原型，Object的原型再通过Object的原型的__proto__找到Object的原型的__proto__的原型为null，就到顶了。所以说原型链是通过__proto__而不是原型，而且这个连接存在在实例和原型之间，和构造函数没有什么关系。
